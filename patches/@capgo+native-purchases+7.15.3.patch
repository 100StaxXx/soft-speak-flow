diff --git a/node_modules/@capgo/native-purchases/ios/Sources/NativePurchasesPlugin/NativePurchasesPlugin.swift b/node_modules/@capgo/native-purchases/ios/Sources/NativePurchasesPlugin/NativePurchasesPlugin.swift
index 7cb921e..fbd2ce5 100644
--- a/node_modules/@capgo/native-purchases/ios/Sources/NativePurchasesPlugin/NativePurchasesPlugin.swift
+++ b/node_modules/@capgo/native-purchases/ios/Sources/NativePurchasesPlugin/NativePurchasesPlugin.swift
@@ -6,6 +6,7 @@ import StoreKit
  * Please read the Capacitor iOS Plugin Development Guide
  * here: https://capacitorjs.com/docs/plugins/ios
  */
+@MainActor
 @objc(NativePurchasesPlugin)
 public class NativePurchasesPlugin: CAPPlugin, CAPBridgedPlugin {
     public let identifier = "NativePurchasesPlugin"
@@ -23,7 +24,7 @@ public class NativePurchasesPlugin: CAPPlugin, CAPBridgedPlugin {
     ]
 
     private let pluginVersion: String = "7.15.3"
-    private var transactionUpdatesTask: Task<Void, Never>?
+    nonisolated(unsafe) private var transactionUpdatesTask: Task<Void, Never>?
 
     @objc func getPluginVersion(_ call: CAPPluginCall) {
         call.resolve(["version": self.pluginVersion])
@@ -38,10 +39,12 @@ public class NativePurchasesPlugin: CAPPlugin, CAPBridgedPlugin {
     }
 
     deinit {
-        if #available(iOS 15.0, *) { cancelTransactionUpdatesListener() }
+        if #available(iOS 15.0, *) {
+            cancelTransactionUpdatesListener()
+        }
     }
 
-    private func cancelTransactionUpdatesListener() {
+    nonisolated private func cancelTransactionUpdatesListener() {
         self.transactionUpdatesTask?.cancel()
         self.transactionUpdatesTask = nil
     }
@@ -50,29 +53,34 @@ public class NativePurchasesPlugin: CAPPlugin, CAPBridgedPlugin {
     private func startTransactionUpdatesListener() {
         // Ensure only one listener is running
         cancelTransactionUpdatesListener()
-        let task = Task.detached { [weak self] in
+        let task = Task { @MainActor [weak self] in
+            guard let self else { return }
+
+            defer { self.transactionUpdatesTask = nil }
             for await result in Transaction.updates {
                 guard !Task.isCancelled else { break }
                 switch result {
                 case .verified(let transaction):
                     // Build payload similar to purchase response
                     let payload = await TransactionHelpers.buildTransactionResponse(from: transaction, jwsRepresentation: result.jwsRepresentation, alwaysIncludeWillCancel: true)
 
                     // Finish the transaction to avoid blocking future purchases
                     await transaction.finish()
 
                     // Notify JS listeners on main thread, after slight delay
-                    try? await Task.sleep(nanoseconds: 500_000_000) // 0.5s delay
-                    await MainActor.run {
-                        self?.notifyListeners("transactionUpdated", data: payload)
+                    do {
+                        try await Task.sleep(nanoseconds: 500_000_000) // 0.5s delay
+                    } catch is CancellationError {
+                        return
+                    } catch {
+                        return
                     }
+                    self.notifyListeners("transactionUpdated", data: payload)
                 case .unverified(let transaction, let error):
-                    await MainActor.run {
-                        self?.notifyListeners("transactionVerificationFailed", data: [
-                            "transactionId": String(transaction.id),
-                            "error": error.localizedDescription
-                        ])
-                    }
+                    self.notifyListeners("transactionVerificationFailed", data: [
+                        "transactionId": String(transaction.id),
+                        "error": error.localizedDescription
+                    ])
                 }
             }
         }
