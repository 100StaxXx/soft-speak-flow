import{l as e,s as d,g as f,h as m,i as b,j as h}from"./index-B9iotTKE.js";const c=(r,i,t)=>Promise.race([Promise.resolve(r()),new Promise((n,s)=>setTimeout(()=>s(new Error(`${t} timed out after ${i}ms`)),i))]),g=async r=>{try{const{data:i}=await d.from("profiles").select("onboarding_completed").eq("id",r).maybeSingle();return i?.onboarding_completed===!0}catch{return!1}},p=async r=>{try{e.debug("[getAuthRedirectPath] Fetching profile...",{userId:r.substring(0,8)});const{data:t,error:n}=await c(()=>d.from("profiles").select("selected_mentor_id, onboarding_completed, onboarding_data").eq("id",r).maybeSingle(),5e3,"Profile fetch");if(n)return e.warn("[getAuthRedirectPath] Profile fetch error, checking if returning user",{error:n.message}),await g(r)?"/tasks":"/onboarding";const s=f(t),a=m(t);return e.debug("[getAuthRedirectPath] Profile fetched",{hasProfile:!!t,onboardingCompleted:t?.onboarding_completed,hasMentor:!!t?.selected_mentor_id,onboardingMentorId:a?.substring(0,8),resolvedMentorId:s?.substring(0,8)}),t?.onboarding_completed&&!t.selected_mentor_id&&a&&Promise.resolve((async()=>{const{error:o}=await d.from("profiles").update({selected_mentor_id:a}).eq("id",r);if(!o){e.debug("[getAuthRedirectPath] Mentor ID updated");return}if(!b(o)){e.warn("[getAuthRedirectPath] Failed to update mentor ID",{error:o});return}const u=h(t.onboarding_data),{error:l}=await d.from("profiles").update({onboarding_data:u}).eq("id",r);if(l){e.warn("[getAuthRedirectPath] Failed to clear stale onboarding mentor ID",{error:l});return}e.debug("[getAuthRedirectPath] Cleared stale onboarding mentor ID")})()).catch(o=>e.warn("[getAuthRedirectPath] Mentor backfill cleanup failed",{error:o})),t?.onboarding_completed?(e.debug("[getAuthRedirectPath] Onboarding complete, redirecting to /tasks"),"/tasks"):!t||!s?(e.debug("[getAuthRedirectPath] No profile or mentor, redirecting to /onboarding"),"/onboarding"):(e.debug("[getAuthRedirectPath] Has mentor, redirecting to /tasks"),"/tasks")}catch(t){return e.error("[getAuthRedirectPath] Error, checking if returning user",{error:t}),await g(r)?"/tasks":"/onboarding"}},_=async(r,i)=>{e.debug("[ensureProfile] Starting...",{userId:r.substring(0,8),email:i?.substring(0,5)});try{const{data:n,error:s}=await c(()=>d.from("profiles").select("id, timezone").eq("id",r).maybeSingle(),3e3,"Profile check");if(s){e.warn("[ensureProfile] Fetch error, continuing anyway",{error:s.message});return}const a=Intl.DateTimeFormat().resolvedOptions().timeZone;if(e.debug("[ensureProfile] Profile check result",{exists:!!n,userTimezone:a}),n)n.timezone!==a?(e.debug("[ensureProfile] Updating timezone..."),Promise.resolve(d.from("profiles").update({timezone:a}).eq("id",r)).then(()=>e.debug("[ensureProfile] Timezone updated")).catch(o=>e.warn("[ensureProfile] Timezone update failed",{error:o}))):e.debug("[ensureProfile] Profile exists, no update needed");else{e.debug("[ensureProfile] Creating new profile...");const{error:o}=await c(()=>d.from("profiles").upsert({id:r,email:i??null,timezone:a},{onConflict:"id"}),3e3,"Profile create");o&&!o.message.includes("duplicate")?e.warn("[ensureProfile] Create error, continuing anyway",{error:o.message}):e.debug("[ensureProfile] Profile created successfully")}}catch(n){e.warn("[ensureProfile] Error (non-blocking)",{error:n})}};export{_ as e,p as g};
