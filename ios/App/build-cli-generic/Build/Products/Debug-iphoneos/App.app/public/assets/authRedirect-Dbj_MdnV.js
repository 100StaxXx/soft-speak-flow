import{l as r,s as a,h as m,i as b,j as P,k as p}from"./index-BJ43zXLh.js";const R=5e3,_=2e3,w=8e3,g=3e3,c="/onboarding",l="/tasks",d=(t,e,n)=>Promise.race([Promise.resolve(t()),new Promise((s,i)=>setTimeout(()=>i(new Error(`${n} timed out after ${e}ms`)),e))]),A=async t=>{try{const{data:e}=await d(()=>a.from("profiles").select("onboarding_completed").eq("id",t).maybeSingle(),_,"Returning user check");return e?.onboarding_completed===!0}catch(e){return r.warn("[isReturningUser] Returning user check failed, defaulting to false",{error:e}),!1}},f=async t=>await A(t)?l:c,E=async t=>{try{r.debug("[getAuthRedirectPath] Fetching profile...",{userId:t.substring(0,8)});const{data:e,error:n}=await d(()=>a.from("profiles").select("selected_mentor_id, onboarding_completed, onboarding_data").eq("id",t).maybeSingle(),R,"Profile fetch");if(n)return r.warn("[getAuthRedirectPath] Profile fetch error, checking if returning user",{error:n.message}),await f(t);const s=m(e),i=b(e);return r.debug("[getAuthRedirectPath] Profile fetched",{hasProfile:!!e,onboardingCompleted:e?.onboarding_completed,hasMentor:!!e?.selected_mentor_id,onboardingMentorId:i?.substring(0,8),resolvedMentorId:s?.substring(0,8)}),e?.onboarding_completed&&!e.selected_mentor_id&&i&&Promise.resolve((async()=>{const{error:o}=await a.from("profiles").update({selected_mentor_id:i}).eq("id",t);if(!o){r.debug("[getAuthRedirectPath] Mentor ID updated");return}if(!P(o)){r.warn("[getAuthRedirectPath] Failed to update mentor ID",{error:o});return}const h=p(e.onboarding_data),{error:u}=await a.from("profiles").update({onboarding_data:h}).eq("id",t);if(u){r.warn("[getAuthRedirectPath] Failed to clear stale onboarding mentor ID",{error:u});return}r.debug("[getAuthRedirectPath] Cleared stale onboarding mentor ID")})()).catch(o=>r.warn("[getAuthRedirectPath] Mentor backfill cleanup failed",{error:o})),e?.onboarding_completed?(r.debug("[getAuthRedirectPath] Onboarding complete, redirecting to /tasks"),l):e?.onboarding_completed===!1?(r.debug("[getAuthRedirectPath] Onboarding marked incomplete, redirecting to /onboarding"),c):!e||!s?(r.debug("[getAuthRedirectPath] No profile or mentor, redirecting to /onboarding"),c):(r.debug("[getAuthRedirectPath] Has mentor, redirecting to /tasks"),l)}catch(e){return r.error("[getAuthRedirectPath] Error, checking if returning user",{error:e}),await f(t)}},M=async t=>{try{return await d(()=>E(t),w,"Auth redirect resolution")}catch(e){return r.error("[getAuthRedirectPath] Hard fallback triggered, routing to /onboarding",{error:e}),c}},y=async(t,e)=>{r.debug("[ensureProfile] Starting...",{userId:t.substring(0,8),email:e?.substring(0,5)});try{const{data:n,error:s}=await d(()=>a.from("profiles").select("id, timezone").eq("id",t).maybeSingle(),g,"Profile check");if(s){r.warn("[ensureProfile] Fetch error, continuing anyway",{error:s.message});return}const i=Intl.DateTimeFormat().resolvedOptions().timeZone;if(r.debug("[ensureProfile] Profile check result",{exists:!!n,userTimezone:i}),n)n.timezone!==i?(r.debug("[ensureProfile] Updating timezone..."),Promise.resolve(a.from("profiles").update({timezone:i}).eq("id",t)).then(()=>r.debug("[ensureProfile] Timezone updated")).catch(o=>r.warn("[ensureProfile] Timezone update failed",{error:o}))):r.debug("[ensureProfile] Profile exists, no update needed");else{r.debug("[ensureProfile] Creating new profile...");const{error:o}=await d(()=>a.from("profiles").upsert({id:t,email:e??null,timezone:i},{onConflict:"id"}),g,"Profile create");o&&!o.message.includes("duplicate")?r.warn("[ensureProfile] Create error, continuing anyway",{error:o.message}):r.debug("[ensureProfile] Profile created successfully")}}catch(n){r.warn("[ensureProfile] Error (non-blocking)",{error:n})}};export{y as e,M as g};
